<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>空间句法整合度计算公式详解</title>
    <link rel="stylesheet" type="text/css" href="documents.css">

</head>
<body>
    <div class="container">
        <h1>空间句法整合度计算公式详解</h1>
        
        <h2>一、概述</h2>
        <p>本应用实现了基于 Space Syntax（空间句法）理论的整合度（Integration）计算，支持两种计算模式：</p>
        <ul>
            <li><strong>拓扑深度模式</strong>（topo）：只计算拓扑距离，每跨越一条线段权重 +1</li>
            <li><strong>角度+长度加权模式</strong>（angle）：考虑转角和线段长度的加权距离（更精确）</li>
        </ul>

        <h2>二、核心概念</h2>
        
        <h3>1. 连接度（Connectivity）</h3>
        <p>连接度是最简单的空间句法指标，表示一条线段与多少其他线段相交。</p>
        <div class="formula">
            <div class="formula-title">连接度公式：</div>
            Connectivity(i) = |{j : line_i 与 line_j 相交}|
        </div>
        
        <h3>2. 深度（Depth）</h3>
        <p>从一条线段（根节点）到另一条线段需要跨越的最小步数或加权距离。</p>

        <h2>三、邻接表构建</h2>
        
        <h3>模式 1：拓扑深度（topo）</h3>
        <div class="formula">
            <div class="formula-title">权重计算：</div>
            weight = 1  （所有相交线段权重相同）
        </div>

        <h3>模式 2：角度+长度加权（angle）</h3>
        <div class="formula">
            <div class="formula-title">权重计算：</div>
            weight = max(0.1, angle × tulipBins × 0.5 + avgLength × 0.001)
            <br><br>
            其中：<br>
            • angle = 两条线段的夹角（0-180度）<br>
            • tulipBins = 8（角度分辨率，默认值）<br>
            • avgLength = (length1 + length2) / 2（两条线段的平均长度）
        </div>

        <div class="note">
            <strong>注意：</strong>角度越大、线段越长，权重越大，表示从一条线转到另一条线的"代价"越高。这模拟了人在空间中移动时的感知：大角度转弯比小角度转弯更"远"。
        </div>

        <h2>四、深度计算（Dijkstra 算法）</h2>
        
        <div class="step">
            <strong>步骤 1：初始化</strong><br>
            • 设置根节点距离为 0：dist[root] = 0<br>
            • 其他所有节点距离为无穷大：dist[i] = ∞
        </div>

        <div class="step">
            <strong>步骤 2：迭代更新</strong><br>
            重复 n 次（n = 节点总数）：<br>
            1. 找到未访问节点中距离最小的节点 u<br>
            2. 标记 u 为已访问<br>
            3. 对于 u 的每个邻居 v：<br>
            &nbsp;&nbsp;&nbsp;如果 dist[u] + weight(u,v) < dist[v]：<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[v] = dist[u] + weight(u,v)
        </div>

        <div class="step">
            <strong>步骤 3：计算总深度（MD - Mean Depth）</strong>
            <div class="formula">
                MD = Σ dist[i]  （i ≠ root, i = 0 到 n-1）
            </div>
            对于不可达的节点（dist[i] = ∞），设置惩罚值：<br>
            dist[i] = n² × 10
        </div>

        <h2>五、整合度公式</h2>

        <h3>方法：简化公式（当前实现）</h3>
        <div class="formula">
            <div class="formula-title">第 1 步：计算转换深度</div>
            totalDepth_conv = (2 × MD) / (tulipBins - 1)
            <br><br>
            其中：<br>
            • MD = 从根节点到所有其他节点的总深度<br>
            • tulipBins = 8（默认值）
        </div>

        <div class="formula">
            <div class="formula-title">第 2 步：计算整合度</div>
            Integration = n² / totalDepth_conv
            <br><br>
            其中：<br>
            • n = 节点总数（所有线段数量）<br>
            • totalDepth_conv = 转换后的总深度
        </div>

        <div class="note">
            <strong>整合度的含义：</strong>
            <ul>
                <li><strong>高整合度</strong>：该线段在路网中处于"中心"位置，从该线段到其他线段的平均距离短</li>
                <li><strong>低整合度</strong>：该线段处于"边缘"位置，从该线段到其他线段的平均距离长</li>
            </ul>
        </div>

        <h2>六、完整计算流程示例</h2>

        <div class="step">
            <strong>假设：</strong>有 3 条线段 A, B, C
            <br><br>
            <strong>邻接关系：</strong><br>
            • A-B 相交，夹角 30°，平均长度 100m<br>
            • B-C 相交，夹角 60°，平均长度 150m<br>
            • A-C 不相交
        </div>

        <div class="step">
            <strong>步骤 1：计算权重（angle 模式，tulipBins=8）</strong>
            <div class="formula">
                weight(A,B) = max(0.1, 30 × 8 × 0.5 + 100 × 0.001) = max(0.1, 120 + 0.1) = 120.1
                <br>
                weight(B,C) = max(0.1, 60 × 8 × 0.5 + 150 × 0.001) = max(0.1, 240 + 0.15) = 240.15
            </div>
        </div>

        <div class="step">
            <strong>步骤 2：计算从 A 到所有节点的深度</strong>
            <div class="formula">
                dist[A] = 0（根节点）<br>
                dist[B] = 120.1（直接相邻）<br>
                dist[C] = 120.1 + 240.15 = 360.25（经过 B）<br>
                <br>
                MD_A = dist[B] + dist[C] = 120.1 + 360.25 = 480.35
            </div>
        </div>

        <div class="step">
            <strong>步骤 3：计算 A 的整合度</strong>
            <div class="formula">
                totalDepth_conv = (2 × 480.35) / (8 - 1) = 960.7 / 7 = 137.24
                <br>
                Integration_A = 3² / 137.24 = 9 / 137.24 = 0.0656
            </div>
        </div>

        <h2>七、参数说明</h2>

        <table>
            <tr>
                <th>参数名</th>
                <th>默认值</th>
                <th>说明</th>
            </tr>
            <tr>
                <td>tulipBins</td>
                <td>8</td>
                <td>角度分辨率，用于角度权重计算</td>
            </tr>
            <tr>
                <td>mode</td>
                <td>'angle'</td>
                <td>'topo' 或 'angle'，选择计算模式</td>
            </tr>
            <tr>
                <td>applyFormula</td>
                <td>true</td>
                <td>是否应用整合度公式（false 则返回原始总深度）</td>
            </tr>
        </table>

        <h2>八、可视化说明</h2>

        <p>计算完成后，应用将根据整合度值为每条线段着色：</p>
        <ul>
            <li><strong>蓝色</strong>：低整合度（边缘位置）</li>
            <li><strong>青色</strong>：中低整合度</li>
            <li><strong>黄色</strong>：中高整合度</li>
            <li><strong>红色</strong>：高整合度（中心位置）</li>
        </ul>

        <div class="formula">
            <div class="formula-title">颜色映射公式：</div>
            normalized = (value - min) / (max - min)<br>
            <br>
            if normalized < 0.33:<br>
            &nbsp;&nbsp;&nbsp;颜色 = 蓝色 → 青色插值<br>
            elif normalized < 0.67:<br>
            &nbsp;&nbsp;&nbsp;颜色 = 青色 → 黄色插值<br>
            else:<br>
            &nbsp;&nbsp;&nbsp;颜色 = 黄色 → 红色插值
        </div>

        <h2>九、实现位置</h2>

        <table>
            <tr>
                <th>功能</th>
                <th>文件</th>
                <th>函数</th>
            </tr>
            <tr>
                <td>邻接表构建</td>
                <td>integration.js</td>
                <td>buildAdjacencySimple()</td>
            </tr>
            <tr>
                <td>整合度计算</td>
                <td>integration.js</td>
                <td>calculateIntegration()</td>
            </tr>
            <tr>
                <td>单节点深度计算</td>
                <td>integration.js</td>
                <td>calculateIntegrationOnDemand()</td>
            </tr>
            <tr>
                <td>Dijkstra 算法</td>
                <td>integration.js</td>
                <td>calculateIntegrationOnDemand() 内部</td>
            </tr>
            <tr>
                <td>颜色映射</td>
                <td>spacial_analyse.js</td>
                <td>valueToColor()</td>
            </tr>
        </table>

        <div class="warning">
            <strong>注意：</strong>WASM 版本的整合度计算目前存在问题（返回 NaN），系统会自动回退到 JavaScript 实现。WASM 仅用于加速邻接表构建和连接度计算。
        </div>

        <h2>十、参考文献</h2>
        <ul>
            <li>Hillier, B., & Hanson, J. (1984). <em>The Social Logic of Space</em>. Cambridge University Press.</li>
            <li>Turner, A. (2007). <em>From axial to road-centre lines: a new representation for space syntax and a new model of route choice for transport network analysis</em>. Environment and Planning B: Planning and Design, 34(3), 539-555.</li>
        </ul>

        <p style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #888; font-size: 14px;">
            文档生成时间：2026-02-06<br>
            应用版本：kjjfmap_web1 (WebAssembly 加速版)
        </p>
    </div>

    <div style="text-align: center;">
    <a href="index.html" class="back-link">返回主界面</a>
    </div>
</body>
</html>
